[{
    "title": "Actor-based programming language \"X\"",
    "slug": "actor-based-programming-language-x",
    "publishedDate": "Tuesday, October 9, 2018",
    "content": [
        "Though there have been no blog posts on the actual development on ttOS, I have been doing some off-and-on work on it. There have been too many changes for me to write them all down, but I can show you this screenshot of the \"changelog\" output:",
        { "image": "/images/changelog.PNG" },
        "It looks very different than the last blogpost, where ttOS was still in text mode, so a lot has changed both visually and internally. I swapped out my old hand-crafted heap allocator for Doug Lea's dlmalloc heap allocator, and received a tremendous speed increase with it.",
        "Another major step in the direction I want to take this project is the X programming language. The version you see in the screenshot above has a fairly complete implementation of my compiler and VM. Actually, the command line interface is implemented using X.",
        { "chapter": "So, what is X?" },
        "I am a very big fan of the actor model. Actually, I use it in one of my bigger projects with which I hope to one day earn some money. What it boils down to, is that you can spawn so-called actors, which are autonomous, isolated \"mini-processes\". Each actor has its own mailbox, and each can send and receive messages to other actors. An actor's state is stored in the context of itself, so the state can only be modified by sending it a message. This has a tremendous positive effect on potential concurrency problems like race conditions!",
        "Another benefit is that the actor model allows for very sophisticated error handling: the actor system (i.e. the collection of all actors within a certain system) is made up of a single tree. Each actor (except for the root actor) is always a child of another actor. Through a process called escalation, a child actor notifies the parent of any exceptions that occur within its execution, and the parent can decide which course of action to take. Some strategies are to simply restart the actor (and its state), or to escalate the exception up to the parent of the parent.",
        "If you want to know more about the actor model, you can visit the Wikipedia article, or the Akka project (which I use the .NET port of, Akka.NET).",
        { "chapter": "Code example" },
        { "codeFile": "/data/example.x", "language": "javascript" },
        "The dollar commands you see are called \"DolDoc routines\". I got inspired by Terry Davis' TempleOS, and decided to implement a subset of it in order to add some graphical spunk to the console.",
        { "chapter": "What's next?" },
        "Currently, I am working on a garbage collector. Right now it only ever allocates objects, but never frees them. Fun for now, but not so fun when it is going to actually do something in the future. And writing a garbage collector is fun anyway ðŸ˜Š.",
        "I also want to add introspection and attributes/annotations to the language. Stay tuned for more. Don't know when though."
    ]
}, {
    "title": "COMBOOT Serial boot loader",
    "slug": "comboot-serial-boot-loader",
    "publishedDate": "Thursday, June 8, 2017",
    "content": [
        "Contrary to what you might believe from the scarcity of updates on my blog, I have been avidly working on my operating system. I added a bytecode interpreter/VM to it so it will host completely sandboxed executables. But, I will write a separate blog post on that subject later.",
        "What I want to write about now is my COMBOOT serial boot loader. I have a physical laptop lying around that I often use to test whether my OS still runs on physical hardware. However, the booting process is tedious: I use pxelinux to serve my kernel over PXE. First of all, the laptop's PXE ROM is slow,  and second, there is a weird bug in pxelinux regarding sizes of multiboot modules.",
        "I have a small holiday right now, so I decided to write a replacement bootloader that should be able to load my kernel over the serial port. To my knowledge, there isn't a boot loader available that does this. The source code of the COMBOOT project can be found on my GitHub page: https://github.com/dseller/comboot/",
        "Below you can see a short video of it in action:",
        "As well as a screenshot of the bootsrv Windows application doing its thing:",
        { "image": "/images/bootsrv1.png" }
    ]
}, {
    "title": "ttOS R0.3",
    "slug": "ttos-r0.3",
    "publishedDate": "Monday, May 16, 2016",
    "content": [
        "I decided that it's time for the R0.3 release. I don't feel like writing a very lengthy post today, but I want to highlight some things.",
        {
            "bulletList": [
                "Multitasking",
                "Logging",
                "BASIC interpreter"
            ]
        },
        { "chapter": "Multitasking" },
        "I implemented multitasking this weekend. It's a cooperative, object-oriented model which uses hardware multitasking. An abstract class Task exists, which can be inherited. The Task contains various attributes that are important to the scheduler (see next section) for correct operation. Also, it contains a protected method Yield which will yield control to the scheduler.",
        { "image": "/images/task.png" },
        "The virtual Run method has to be implemented in the inheriting class. This method contains the code that has to be run inside the multitasking environment.",
        "Multitasking requires a scheduler. Whether it's a simple round-robin one, or something priority-based, a scheduler is necessary to distribute the processor time. I am very intrigued by the so-called lottery scheduler. Like it explains in the link, it allows for a sophisticated priority system: if it requires more priority, just give it more tickets! Also, I'm simply fascinated by the concept :). So yep, that's what the Tickets attribute is in the class diagram above!",
        "In this screenshot, you can see two separate tasks outputting either X or O to a view. As is normal in a multitasking system, it is not a consecutive string of alternating Xs and Os, but you can see the effect of the scheduler quite well.",
        { "image": "/images/multitasking.png" },
        { "chapter": "Logging" },
        "Until now, I had a \"debug view\" to which I simply dumped all kinds of system logging. I felt that it was time to organize this a little bit more. I've been toying with the idea of routing log messages over the serial port, so the logging system needed an overhaul anyway.",
        "I introduced logging levels (debug, info, warning, error) and a timestamp. The different logging levels are also printed in a different color, so bad things are now visible quite immediately. As seen in the screenshot below, the debug view has also been renamed to \"log\".",
        { "image": "/images/logging.png" },
        "The next step would be to write some kind of \"channel system\", so I can also output the log to the serial port.",
        { "chapter": "BASIC interpreter" },
        "As a little gimmick to show off the (multi)tasking system, I implemented the very tiny uBASIC interpreter as a Task.",
        "With a few minor improvements to the View code, it's now possible to run a simple BASIC script, as demonstrated in the YouTube video below:"
    ]
}, {
    "title": "vhdutil - VHD file attach/detach tool",
    "slug": "vhdutil-vhd-file-attach-detach-tool",
    "publishedDate": "Saturday, May 7, 2016",
    "content": [
        "I just published a small tool to my Github account. While developing ttOS, I have been struggling to find a virtual hard disk format that:",
        {
            "bulletList": [
                "Is compatible with most x86 virtual machines",
                "Can be written to a device (USB stick, cloned to a real HDD, etc.)",
                "Is mountable in Windows, so I can include it in my build process"
            ]
        },
        "Turns out the best fit is the \"Virtual Hard Disk\" format. In Windows, it's possible to mount VHD files using the management console. But I don't want to go through all the hassle to mount it with a few mouse clicks, build the kernel, unmount it with more mouse clicks, before I can actually test it.",
        "So I made vhdutil, which is available here: https://github.com/dnifan/vhdutil"
    ]
}, {
    "title": "ttOS R0.2",
    "slug": "ttos-r0.2",
    "publishedDate": "Wednesday, April 27, 2016",
    "content": [
        "The first blogpost since a month! And I have a lot to show (I think). First, a quick round-up of the latest modifications:",
        {
            "bulletList": [
                "Added views system",
                "Implemented kernel service model",
                "Heap locking",
                "Safety checks & documentation",
                "Added version numbering"
            ]
        },
        "Details after the break!",
        { "chapter": "Views" },
        "A \"view\" in ttOS roughly resembles a window or console. Developers are able to open up to 10 views and give them a title. After that, it's possible to interact with the view (e.g. writing/reading). Users can switch views using CTRL-0 to CTRL-9.",
        "I have reserved view 0 as the \"debug view\". The kernel will spit out debug messages there, so it doesn't clutter the actual views, and I'm still able to read the debug stuff.",
        { "image": "/images/view1.png" },
        { "image": "/images/view2.png" },
        "The view's title can be seen in the top-left corner, near the current date/time.",
        { "chapter": "Service model" },
        "I must admit, this sounds a lot more awesome than it really is. Before this redesign, I simply had a few manager classes which could be retrieved from the kernel singleton. But, this clutters the kernel class, because every time I make a new manager for something, it must be added to the kernel as a private field and a public getter method.",
        "So I started with a ServiceContainer class. This class simply contains a collection of Services. I can register services with it, as well as get a specific service using templates (GetService<ChronoService>()).",
        { "image": "/images/servicecontainer.png" },
        "The next step was to refactor all manager classes to inherit from the Service base class, and simply register them when the kernel starts. All references to the manager classes had to be replaced with a GetService() call. It seems a lot nicer now, more modular.",
        "Because of this, I can now also print a list of registered services. It doesn't really serve a particular purpose, but it looks cool ðŸ˜Š.",
        { "image": "/images/view3.png" },
        { "chapter": "Heap locking" },
        "This is just a little nifty feature I added to make sure that certain allocated memory areas can NEVER be freed. For example, you don't want anyone to do \"free(kernel)\". Especially handy for those methods that simply return a pointer to an otherwise managed resource, like the GetVideoBuffer() method in the View class. It returns a pointer to raw data. A developer is able to free this memory area. If this happens, your entire view will be filled with garbage.",
        "So I set out to add the heap locking feature to the heap manager. Basically, I added an 8-bit flags field to the block header. Only one flag is supported, the LOCKED (0x01) flag. Using heap_set_lock(ptr, bool) you can either enable or disable the lock. When the free() method stumbles upon a locked block, it will crash the system (which is better than undefined behavior).",
        { "chapter": "Safety checks & documentation" },
        "Basically, I added a whole bunch of asserts throughout the kernel code. There's a configuration flag called \"RELAXED_ASSERT\". If set to 1, it just shows a debug message. If set to 0, it will crash the kernel.",
        "I also started to add doxygen documentation to the kernel. This automatically creates some really cool diagrams:",
        { "image": "/images/doxygen.png" },
        { "chapter": "Version numbering" },
        "I simply started to tag certain commits in the Git repository with a version. This version number is also shown in the default kernel view (as seen in the screenshots above).",
        "This way, whenever I decide that it's time for a release, I can also write a blogpost about it!"
    ]
},{
    "title": "Switching to real mode to use BIOS functions",
    "slug": "switching-real-mode-bios-functions",
    "publishedDate": "Tuesday, March 22, 2016",
    "content": [
        "Well, I finally did it. It took me exactly two days (or 16 hours) to write a piece of code that would allow me to temporarily drop back to real mode, call some BIOS interrupts, and then go back to protected mode again. The fact that I use MSVC++ and the COFF object file format didn't actually help me, as I had to be quite inventive to work around the limitations of the COFF format.",
        "Anyway. I have now used this technique to upgrade my console from 80x25 characters to a whopping 80x50! So one might wonder if this was worth all the time. I guess so, since I can now also switch to graphics mode, and get ACPI information, et cetera.",
        "Look at this huge console! It seems like the VGA cursor suddenly stopped working though. I'm thinking of simply implementing my own using the underscore character, and the PIT timer.",
        { "image": "/images/ttos_vbox.png" }
    ]
}, {
    "title": "Syntactic sugar with C++ and more",
    "slug": "syntactic-sugar-with-cpp-and-more",
    "publishedDate": "Thursday, March 17, 2016",
    "content": [
        "So in my previous blogpost I briefly spoke about switching to C++ from pure C. I really like it so far. Since the majority of code I write at work is C#, I've become very accustomed to object oriented thinking.",
        "Currently, the driver model, device model, interrupt handling, terminal, and more have been migrated to C++. Also, I implemented a LinkedList<T> class.",
        { "chapter": "Driver/device model" },
        { "image": "/images/driver1.png" },
        "As you can see, there is one \"root\" base class that is the base to all driver implementations. One layer below that are type classes, which allow for a layer of abstraction based on the kind of device. On the bottom layer are the concrete implementations.",
        "Usually, a driver has a relation to a \"device\". For instance, the PITDriver has 3 PITDevice instances, one for each channel of the PIT. The AtaDriver is able to detect the devices that are connected to the computer, and will create an AtaDevice instance for each of them:",
        { "image": "/images/driver2.png" },
        "This way, I can tell my DeviceManager instance to give me a Keyboard driver, like this:",
        "Note that the KERNEL macro is just a shortcut to access the kernel singleton.",
        { "chapter": "Interrupt handling" },
        "Before the switch to C++, the only way to register Interrupt Service Routines was to use a this arbitrarily named function \"idt_register\" that would add it to a table. Now, there is one manager class, which contains a linked list of instances of type InterruptHandler. These classes contain a Handle() function to execute whatever code needs to be executed on interrupt.",
        "There is also one single generic ISR which will simply ask the manager to return the InterruptHandler for a given IRQ. The ISR will then, in turn, call the (virtual) Handle method.",
        { "image": "/images/driver3.png" },
        { "chapter": "File systems" },
        "One base class FileSystem is defined, which contains all virtual methods a file system should contain. The class VirtualFileSystem inherits from FileSystem, and acts as a Proxy because it propagates all calls to the concrete FileSystem implementation. Currently only FAT16 is supported, but this can easily be extended by simply registering a new class.",
        "So, implementing a terminal command to print a directory listing is as simple as:",
        "Pay attention to the GetVfs() call to the kernel instance. This will return the VFS, and allows us to create new files, open files, list files, delete files, etc.",
        { "chapter": "Visual enhancements" },
        "The terminal has been extended with a \"status bar\" at the top. The idea is that this status bar does not scroll along with the rest of the terminal, so it can contain some information which is always interesting to show. Currently it shows the current date/time, and the current RAM usage. See below for a screenshot.",
        { "image": "/images/ttosa1.png" },
        "The date and time is retrieved from the CMOS chip.",
        { "chapter": "Other stuff" },
        "If you have been paying close attention, you might have noticed in the screenshot above that I added PCI support. Kind of. It's very basic at the moment, but the PCI manager actually retrieves the CPU I/O ports from the PCI configuration address space for the IDE controller. The ATA driver is then registered by the PCI manager with the correct data.",
        "Also, C++ RTTI sucks. It is one of few evidences that C++ is just built on top of C, instead of being designed from scratch. I have implemented support for the Visual C++ RTTI ABI, and it really felt like a necessary evil.",
        "The terminal has received a new feature: press TAB to cycle through previous commands. I was growing tired of having to re-enter all commands every time, so I implemented this feature.",
        "I should rewrite my keyboard driver. I thought I had scan codes/keycodes covered pretty well, but I made a few design errors here and there. As a result, the current keyboard driver can not support more than 0xFF keycodes. \"Exotic\" keys like the function keys, directional keys are not working because of that. ",
        "I have been tinkering with higher resolutions for the terminal. Not possible with GRUB as the bootloader, because it's set to default 80x25. The easiest way is to use VBE but this requires my own bootloader. There are more reasons to write my own bootloader ,such as ACPI, and some more I forgot ;-). So that might happen as well."
    ]
}, {
    "title": "OS: Switch to C++",
    "slug": "os-switch-to-cpp",
    "publishedDate": "Sunday, February 28, 2016",
    "content": [
        "So yeah, it has been a while since the last update. I don't feel like writing a lengthy post like last time, so I'm just going to list the progress since the last post (on January 27th!).",
        {
            "bulletList": [
                "I switched from C to C++. While writing my device driver code I noticed I was thinking object-oriented, but I could not actually code object-oriented. The source has not been fully migrated yet, as there are (of course) some problems with this. I also discovered I do not know much about the internals of C++, so it's a nice learning experience.",
                "Dropped floppy support. Damn those things and damn FDCs. ",
                "Added hard disk support by PIO ATA. Maybe I will switch to DMA mode some day, but for now PIO is good enough.",
                "Dropped FAT12 support and switched to FAT16. Since I dropped floppy support and switching to hard disks, I did not see the point of such small partitions, and FAT12 and FAT16 are quite similar.",
                "Added a VFS (Virtual File System). It's now possible to open files, print directory listings, etc. All independent of the underlying file system of course ðŸ˜Š.",
                "Preliminary kernel API using soft interrupts (0x80). Had a fight with interrupt handling while in a kernel API call, only had to enable interrupts using STI... ðŸ˜Š",
                "PCI enumeration code. Although it seems like it does not really enumerate everything, it misses the NE2000 ethernet card in Bochs. The enumeration doesn't do anything other than print it on screen yet. ",
                "Various bugfixes & improvements like extending the heap stats structure."
            ]
        },
        "I'm trying to implement a LinkedList<T> class. It's not exactly going according to plan..."
    ]
},{
    "title": "A tale about storage devices & terminals",
    "slug": "a-tale-about-storage-devices-terminals",
    "publishedDate": "Wednesday, January 27, 2016",
    "content": [
        "A lot has happened to ttOS since my last blogpost. If my memory serves me right, my previous blogpost contains information about programming the PIT. I will focus on a few key subsystems which have been worked on.",
        { "chapter": "Physical memory management" },
        "I have written a botched implementation of a physical memory manager. Granted, I rarely use it in my code. It needs a complete redesign and rewrite as soon as possible, because I'm constantly working around having no dynamic memory allocation.",
        "Because ttOS will not feature multiple tasks or processes running at once, paging and fancy memory management is not required. There is only a kernel and 1 optional user (ring 3) process running at a time. Therefore, the memory can easily be split in two regions; kernel and user space.",
        "This is why I'm not convinced that I need the distinction between a physical and a virtual memory manager. I just need a kernel memory manager (KMM) and a user memory manager (UMM).",
        "I think I will introduce an abstraction layer for the memory managers. Because I'm not sure which technique to use, and because it's interesting to play with different approaches, I want a relatively easy way to switch implementations.",
        "The concept of a stack-based memory allocator intrigues me.",
        { "chapter": "Keyboard driver" },
        "Preliminary driver to be able to read characters from the keyboard. It's a minidriver that has no abstraction layer yet. This will be improved later, so that terminal input can be sent from any input driver.",
        "Right now, it's really hardcoded in the kernel. The getch() function just waits for IRQ1 and returns the value. Ideally, the getch() function would ask the input driver for a character.",
        { "chapter": "Terminal" },
        "I'm pretty happy with my current terminal, even though it's still a hardcoded part of the kernel. The terminal supports a limited number of commands which can be dynamically registered whenever the system requires it. This means that drivers can register commands to be able to interact with hardware. The commands are implemented in a function in the kernel address space.",
        "The logic for reading and parsing the command line is implemented in a state machine. See the diagram below:",
        { "image": "/images/TerminalState.png" },
        "Unfortunately, because there is no memory allocator, the system is bound to a few fixed limitations. For example, only 3 parameters are supported, and each value is stored statically in kernel address space. When the memory manager is finished, I will fix this limit.",
        { "chapter": "Storage devices" },
        "Save the best for last, they say, right? I've been experimenting with a modular driver framework, and storage devices seemed to be a simple way to test this. So, basically, a storage device is a device which contains data and can be accessed by the system. For example:",
        {
            "bulletList": [
                "RAM Disk",
                "Hard Disk",
                "Floppy",
                "CD-ROM",
                "USB Stick"
            ]
        },
        "The instances of these storage device types are stored in the Storage Device Table. You can see the struct definition below:",
        { "gist": "39e50608099499e971ba"},
        "So, the name field is obvious. It gives a unique name to the device attached to the system. The type field tells you the type of the device. The driver field allows you to directly access the driver object, so you can read or write blocks. data0 and data1 are used as metadata, the driver decides what to put there. RAM disks will store the address and size of the ramdisk for example.",
        "This is what the storage device driver struct looks like:",
        "The name is used to identify the driver. I also use it to include a version number. detect_devices exposes a function to allow the driver to search the system for devices and register them in the Storage Device Table. initialize will do whatever initialization the driver needs. read_lba and write_lba will tell the driver to respectively read or write sectors to a LBA.",
        { "chapter": "The RAM Disk implementation" },
        "I have a floppy driver, but it is too crappy for a reliable test. So I wrote a RAMDisk driver. I will explain what happens in each function.",
        "We begin with ramdisk_get_driver. This function is called when the drivers are initialized to store the drivers in the storage device drivers table. The function constructs an instance of the storage_device_driver struct and populates it.",
        "The ramdisk_init simply registers a new terminal command \"ramdisk\".",
        "ramdisk_cmd_handler is the handler for the ramdisk terminal command. Based on the amount of parameters it will create a ramdisk with a fixed size at a static or dynamic memory address.",
        "The ramdisk_create and ramdisk_create_with_address simply create a storage device table entry and register the device. When this is done, the terminal sd command can be used to show a listing of storage devices.",
        "Finally, ramdisk_read_lba and ramdisk_write_lba will respectively read and write from the memory address as specified in the storage device table entry. See how I used a static variable to act as a \"buffer\"? That's because I don't have dynamic memory allocation :(.",
        { "chapter": "Conclusion" },
        "Like I stated in the beginning, a lot of work has been done. I really want to focus on getting the memory management done. I will write a new post about that when it's finished.",
        "Thanks for reading, and see you next time!"
    ]
},{
    "title": "Update on O/S development",
    "slug": "update-on-os-development",
    "publishedDate": "Saturday, January 16, 2016",
    "content": [
        "Finally, a new blogpost about the original purpose of this blog; operating system development.",
        "I came across a project I started in 2010, called ttOS. It was in a very bad shape and it was obvious that I didn't really know what I was doing back then. Nonetheless, I scrolled through it and figured out what had to be done to clean it up.",
        "First of all, ttOS has a major upside compared to the one I started this blog with. The kernel is written using Visual Studio! So I could write my kernel using my favorite IDE, instead of some half-assed Linux text editor tool.",
        "Second, it had some neat little tools in the folder structure to facilitate building a bootable image. Nice to have.",
        "So I decided to abandon the old OS and continue this one. Luckily, the ttOS kernel already knew how to set up the GDT, so that wasn't much of a hassle anymore. The IDT was half implemented, so I continued on that subject.",
        "After setting the CPU exception vectors 0-31 in the IDT, I began programming the PIC. Really neat little piece of code, nothing special. I just do the same everybody else does:",
        { "image": "/images/kernela1.png" },
        "Great. Now on to testing the PIC by adding a IRQ handler!",
        "Unfortunately, this is where I failed miserably. I had tried to use C to directly implement an interrupt routine. I thought if I used __declspec(naked), that it would be alright! This turned out to be so false! Ultimately, I used an assembly file called \"comp_isrs.asm\". Comp stands for \"components\", which originates from the way I organize my kernel source (more on that later, perhaps). Also, MASM is really weird if you're used to NASM. ðŸ˜Š"
    ]
},{
    "title": ".NET Collections & deferred execution with IQueryable",
    "slug": "net-collections-deferred-execution-iqueryable",
    "publishedDate": "Thursday, June 11, 2015",
    "content": [
        "One of the advantages of modern programming languages and frameworks is that they provide a lot of functionality to \"make it easier\" for developers to build their software. However, in most cases it is still very important to know what happens under the hood. For example, it will be easier for a developer to analyse the impact of changes, anticipate on how 3rd party libraries might work, or optimize their code properly.",
        "In this blogpost, I will try to explain the differences between the various collection interfaces supplied by the .NET Framework, and their uses. I will also give an example how improper knowledge of this subject can lead to problems in the case of IQueryable. A little bit of background information and theory is explained to understand some of the decisions made regarding collections.",
        { "chapter": "Iterators" },
        "In object-oriented programming, it is common to use so-called \"design patterns\". I will not go in-depth on the concept of design patterns, but they are basically patterns which can be used by developers to create understandable and structured code. Click this link to learn more about them.",
        "An important pattern to understand for this blogpost is the \"iterator pattern\". The definition of the iterator pattern according to Gang of Four:",
        { "quote": "Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation." },
        "Below is a class diagram of the traditional iterator pattern. The most important aspect of this diagram is the Iterator object. By using the Next() method, you can sequentially iterate over the collection, and thereby fetch the next object.",
        { "image": "/images/iterator.gif" },
        "If you have the feeling you need more information about this pattern, make sure to do that now.",
        { "chapter": "IEnumerable" },
        "According to MSDN, the IEnumerable interface:",
        { "quote": "Exposes an enumerator, which supports a simple iteration over a non-generic collection." },
        { "image": "/images/IEnumerable.png" },
        "The IEnumerable interface is the core of all collections in .NET. It is part of the .NET implementation of the iterator pattern as explained above. This also allows the use of the foreach keyword. As we all know, the foreach keyword is used to iterate over a collection.",
        "As written earlier, it is very important to note that the iterator pattern hides the underlying representation of the collection. This makes it very easy to forget what is actually happening under the hood. We will come back to this later in this post.",
        { "chapter": "ICollection" },
        "According to MSDN, the ICollection interface:",
        { "quote": "Defines size, enumerators, and synchronization methods for all nongeneric collections." },
        { "image": "/images/ICollection.png" },
        "The ICollection interface inherits from the IEnumerable interface. It extends the IEnumerable by simple functionality, like the ability to get the size of a collection and synchronizing/locking features.",
        "By inheriting the IEnumerable interface, it enables you to iterate over an object that implements the ICollection interface (using the foreach keyword).",
        { "chapter": "IList" },
        "According to MSDN, the IList interface:",
        { "quote": "Represents a non-generic collection of objects that can be individually accessed by index." },
        { "image": "/images/IList.png" },
        "As you can see, the IList interface provides methods to manipulate the collection. It also allows the developer to index the collection (as defined by MSDN). Concrete implementations are familiar for this interface:",
        {
            "bulletList": [
                "Array (also int[], etc.)",
                "List",
                "LinkedList",
                "ArrayList"
            ]
        },
        "Again, since this interface inherits from IEnumerable, it becomes possible to iterate these objects.",
        { "chapter": "Potential problem with IQueryable" },
        "According to MSDN, the IQueryable interface:",
        { "quote": "Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified." },
        "This interface is, semantically speaking, not an actual \"collection\" interface. However, it inherits from the IEnumerable interface. And this is a perfect example where improper knowledge of the above can cause a pretty bad situation.",
        "First, a little background information on the IQueryable interface.",
        "Since the rise of ORM tools (Object-relational mapping), it has become \"easier\" for developers to interact with databases or datasets. Instead of writing queries, it has become possible to use a code-based approach, and let a query generator create the actual queries for you. This makes code incredibly portable, since you don't have to write the queries for each different database engine.",
        "Some ORM tools will expose this functionality using the IQueryable interface. Which in itself is a great idea. It provides a single interface with which you can interact to dynamically build database/dataset queries, using Linq for example.",
        "But the IQueryable interface inherits from the IEnumerable interface. This allows us to iterate the object, which is something we all want to do at some point. However, in most cases, every time you use the foreach-keyword on a this object, you execute a query on the database. That means that if you iterate the same object twice, the same query is executed twice.",
        "That of course, has a reason. Because if you perform an action on a collection, modify the dataset, and then perform the same action again, you might expect the results to be different than the first time.",
        "The point is, some developers may regard the IQueryable object as a collection that is, at a certain point, a filled collection and is non-volatile. Therefore this may lead to unintened consequences such as too much load on a database server.",
        "A commonly made mistake is to pass references to the IQueryable objects instead of retrieving the required results using for example ToList() or ToArray() and storing the results in memory."
    ]
},{
    "title": "Quick update",
    "slug": "quick-update",
    "publishedDate": "Thursday, February 19, 2015",
    "content": [
        "Small update using the Blogger app for Android. I made a Git branch for development of a Linux build. The JIT compiler is now buildable in Debian 6, and runs like a charm! Yay!",
        "There's a minor issue with the CPU's instruction cache flushing mechanism but that seems to be resolved. I just need to port the psystem library (libpsystem.so will be its name instead of psystem.dll).",
        "Then the final thing that remains is to port the assembler, and the full suite runs in Linux ðŸ˜Š"
    ]
}, {
    "title": "Relocation part II & general improvements",
    "slug": "relocation-part-ii-general-improvements",
    "publishedDate": "Saturday, November 8, 2014",
    "content": [
        "I have split the code and data memory areas now. The relocation table has allowed me to do this without any real problems. It's nice!",
        "I also implemented some general improvements. I added an x86 disassembler to debug the compiled code on run-time. The library I used is diStorm. This simplifies the process immensely because until now I had to copy/paste the hex dump into a disassembler every time. Now it just shows me the disassembly in the log, like this:",
        "Because the project is getting larger and larger, I also felt the need for a proper configuration system. I used libconfig for this. You can see an example config file here. As you can see, this configuration library allows for a much more extensive configuration than for example a .INI file (which the original Pessego VM uses). It is also more readable than XML, and it has more formatting options than JSON.",
        "When I implemented this library, I got annoyed by the fact that I now had 2 configuration files, one for log4cpp and one for pjitgen. I solved this by making a minor change to log4cpp and allowing me to put log4cpp configuration in the general configuration file. The pjitgen config currently looks like this:",
        "I'm not sure what I will be posting next. I'm having issues with the relocation syscall invocation in combination with a jump to a pointer at a certain address though. Perhaps I will make another post about that soon."
    ]
},{
    "title": "Relocation part I",
    "slug": "relocation-part-i",
    "publishedDate": "Wednesday, November 5, 2014",
    "content": [
        { "image": "/images/relocation.png" },
        "Progress has been going slow lately. I'm a little preoccupied with other things. However, I have been working on pjitgen (that's the library name btw).",
        "So... I was going through the branching/control flow opcodes, which I already expected to be difficult to implement. The problem is, the assembler will calculate addresses and offsets according to the original instruction sizes. However, the instruction sizes in x86 are different than the instruction sizes of Pessego. The easiest solution is to make a temporary relocation table that holds a mapping for every instruction address in Pessego address space to x86 address space within the allocated executable memory area. This way I can just lookup the new address by indexing the table with the original address. Sounded like a plan!",
        "But then... damn! Of course, the instructions ahead had not been processed yet so every reference to a label that's after the current instruction could not be compiled. I fixed this by implementing a special pre-compilation pass that will populate the relocation table before actually compiling the code.",
        "Another problem was the situation when you would use \"JMP A\" (which will jump to the address stored in register A). You see, A would contain for example 0, this is the first instruction in the Pessego address space. Of course, this needs to be relocated, but the compiler can not inject a relocated address in the code like I did with immediate addressing, because the contents of A are volatile. To solve this challenge, I added an internal syscall which can be used to get a relocated address from within the generated x86 code on runtime.",
        "By now, it mostly works. The only problem remaining is the separation of data and code sections. Sometimes, \"0\" will refer to the beginning of the data section (effectively; beginning of the executable memory), but sometimes \"0\" refers to the code offset within the executable memory. This will most likely be fixed if I can normalize what \"0\" means in this context. I might also move the data section out of the executable memory. That seems nicer, more secure, and makes more sense too.",
        "To be continued..."
    ]
}, {
   "title": "The multi-dimensional translation table",
   "slug": "the-multi-dimensional-translation-table",
   "publishedDate": "Saturday, November 1, 2014",
   "content": [
       "One of the biggest hurdles in this project has been the mechanics of translating Pessego-bytecode to x86 machine code (of course, it's a JIT!). I took 3 different approaches;",
       { 
           "bulletList": [
               "A completely control-flow based approach, checking the Pessego RM bytes bit-by-bit to construct an x86 instruction",
               "An experiment with a multi-dimensional \"translation table\". ",
               "A hybrid of the former 2"
           ] 
        },
        "The first approach failed miserably. The instruction set is familiar to x86, but nowhere near compatible enough that it can be translated one-to-one. Quite soon I changed my approach.",
        "The translation table had the upside that in theory it should be very fast because you index the translation table with the elements that form a Pessego instruction. Indexing takes some time, but a lot less than shifting and comparing bits on runtime. So, eager to find out whether this concept would work, I began to rewrite my translator for the 'PUT' opcode. However, I soon realized that this would take me ages. There are 2553 possible combinations (16,481,375 to be precise).",
        "I pondered quite a while how to solve this matter. The idea of populating the matrix on runtime crossed my mind, but I figured that would not work because the x86 instructions are not compatible enough. Soon enough I just tried something and I managed to reduce the length of my \"PUT\" translator code from 700 lines and 75% completion to 156 lines and 100% completion.",
        "How did I do it? Well, instead of abandoning the idea of automating the population of the table, I began to search for specific similarities between x86 and Pessego instructions. Also, when I learned more about how the x86 instructions are formed (opcode, R/M modifiers, etc.) I was able to programmatically generate the necessary bytes. Success!"
   ]
},{ 
    "title": "My JIT compiler",
    "slug": "my-jit-compiler",
    "publishedDate": "Tuesday, October 28, 2014",
    "content": [
        "Been a long time since the last update. I also suspended development of my operating system and moved on to enhancing my virtual machine project called \"Pessego\". I wrote the software back in 2008 or something and was a glorified bytecode interpreter with crappy assembler.",
        "The new version has a Flex/Bison-powered assembler and will be powered by a... *drumroll* Just-in-time compiler! Like all the big boys have ;-).",
        "It's written in C++, and has log4cpp as a logging framework at the moment. It's not in a very advanced state but as of this evening, it recognizes the first instruction! Consider the following \"program\", it is written in PAsm, not x86 Assembly:",
        { "codeFile": null },
        "You would probably translate the \"put\" instruction to \"mov eax, $1badb002\", which is exactly what it will do. It generates the byte sequence [$B8, $02, $B0, $AD, $1B]. The next step is to allocate some virtual memory using the Windows API, mark it as executable, create a function pointer and call the function and my initial JIT compiler just took its first baby steps!",
        { "image": "/images/p1.png" }
    ]
},{
    "title": "The GDT & IDT",
    "slug": "the-gdt-idt",
    "publishedDate": "Wednesday, July 2, 2014",
    "content": [
        "It turns out the reason why my kernel would not boot had nothing to do with my amd64 architecture! The linker script was not properly written so the multiboot header was not in the right place!",
        "So I have finally made some progress:",
        { "image": "/images/tomahna_01.png" },
        "As you can see, I have a rudimentary way to show text on-screen. It simply writes stuff to the memory-mapped video area at 0xB8000. It also has a simplified implementation of rendering newlines and stuff. The hexadecimal numbers are rendered by using the high and low nibble and adding either '0' or 'A' to them.",
        "The global descriptor table and interrupt descriptor table are also loaded as of 10 minutes ago. The GDT is using a flat memory model, so all data segments are mapped 0x00000000 to 0xFFFFFFFF.",
        "The interrupt descriptor table has a really simple handler for now, I might need to add default handlers with default panic screens for each of them... perhaps later :-)."
    ]
},{
    "title": "Setting up the system",
    "slug": "setting-up-the-system",
    "publishedDate": "Monday, June 30, 2014",
    "content": [
        "Well, hello there! Welcome to my blog. I will use this blog as some kind of journal to follow my progress in building my own kernel/OS.",
        "I have been busy setting up my development machine. I installed Debian 7.5 (amd64) on it, but I have not been able to compile the kernel at the moment. Will install x86 version of Debian 7.5 tonight."
        
    ]
}]